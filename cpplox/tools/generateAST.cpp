#include "generateAST.h"
#include <iostream>

int main(int argc, char **argv) {
  if (argc != 2) {
    throw new std::runtime_error("Usage: generateAST <output directory>\n");
    exit(-1);
  }
  std::cout << "Generating AST in location:" << std::endl;
  std::string outputDir = argv[1];
  std::cout << outputDir << std::endl;
  defineAst(outputDir, "Expr",
            std::vector<std::string>{
                // add : instead of ->
                //     , instead of |
                "Binary   : Expr left, Token op, Expr right",
                "Grouping : Expr expression", "Literal  : std::any value",
                "Unary    : Token op, Expr right"});
}

void defineAst(const std::string outputDir, const std::string baseName,
               const std::vector<std::string> types) {
  std::string path = outputDir + "/" + baseName + ".cpp";
  std::ofstream file(path);

  file << "// Path: " << path << std::endl;
  file << "// This file was automatically generated by generateAST.cpp"
       << std::endl;

  file << "#include \"./token.h\"" << std::endl;
  file << "class " << baseName << " {"
       << std::endl; // This is the abstract base class declaration
  for (std::string type : types) {
    std::string className = trim(type.substr(0, type.find(":")));
    std::string fields = trim(type.substr(type.find(":") + 1));
    defineType(file, baseName, className, fields);
  }
  file << std::endl;
  defineVisitorAndAccept(file, baseName, types);
  file << "};" << std::endl;
  file.close();
}

void defineType(std::ofstream &file, const std::string baseName,
                const std::string className, const std::string fieldList) {
  file << "\tclass " << className << " {"
       << std::endl; // nested class declaration(is static because cpp has
                     // nested static classes by default)

  std::vector<std::string> fields = split(fieldList, ", ");

  file << "\t\t" << className << "("; // constructor
  for (std::string field : fields) {
    std::string type = trim(field.substr(0, field.find(" ")));
    std::string name = trim(field.substr(field.find(" ")));
    if (field != fields.back())
      file << type << " *" << name << ", ";
    else
      file << type << " *" << name << ") {" << std::endl; // constructor
  }

  for (std::string field : fields) {
    std::string name = trim(field.substr(field.find(" ")));
    file << "\t\t\tthis->" << name << " = " << name << ";"
         << std::endl; // this.field = field;
  }
  file << "\t\t}" << std::endl;
  for (std::string field : fields) {
    std::string type = trim(field.substr(0, field.find(" ")));
    std::string name = trim(field.substr(field.find(" ")));
    file << "\t\tconst " << type << " *" << name << ";"
         << std::endl; // field declaration
  }
  file << "\t};" << std::endl;
}

std::vector<std::string> split(const std::string &str,
                               const std::string delimiter) {
  std::vector<std::string> tokens;
  size_t prev = 0, pos = 0;
  do {
    pos = str.find(delimiter, prev);
    if (pos == std::string::npos)
      pos = str.length();
    std::string token = trim(str.substr(prev, pos - prev));
    if (!token.empty())
      tokens.push_back(token);
    prev = pos + delimiter.length();
  } while (pos < str.length() && prev < str.length());
  return tokens;
}

std::string trim(const std::string &str) {
  size_t first = str.find_first_not_of(' ');
  size_t last = str.find_last_not_of(' ');

  if (first == std::string::npos || last == std::string::npos) {
    // The string is empty or contains only spaces
    return "";
  }

  return str.substr(first, last - first + 1);
}

void defineVisitorAndAccept(std::ofstream &file, const std::string baseName,
                            const std::vector<std::string> types) {
  file << "\t\tclass Visitor {" << std::endl;
  std::string allTypes = "";
  for (std::string type : types) {
    std::string typeName = trim(type.substr(0, type.find(":")));
    if (type != types.back())
      allTypes += typeName + ", ";
    else
      allTypes += typeName;
  }
  for (std::string type : types) {
    std::string typeName = trim(type.substr(0, type.find(":")));
    file << "\t\t\tvirtual std::variant<" << allTypes << "> visit" << typeName
         << baseName << "(" << typeName << " " << baseName << ") = 0;"
         << std::endl;
  }
  file << "\t};" << std::endl;
  file << "\tvirtual std::variant<" << allTypes
       << ">accept(Visitor visitor) = 0;" << std::endl;
}
