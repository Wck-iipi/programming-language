#include "generateAST.h"
#include <iostream>

int main(int argc, char **argv) {
  if (argc != 2) {
    throw new std::runtime_error("Usage: generateAST <output directory>\n");
    exit(-1);
  }
  std::cout << "Generating AST... in:" << std::endl;
  std::string outputDir = argv[1];
  std::cout << outputDir << std::endl;
  defineAst(outputDir, "Expr",
            std::vector<std::string>{
                // add : instead of ->
                //     , instead of |
                "Binary   : Expr left, Token op, Expr right",
                "Grouping : Expr expression", "Literal  : Object value",
                "Unary    : Token op, Expr right"});
}

void defineAst(const std::string outputDir, const std::string baseName,
               const std::vector<std::string> types) {
  std::string path = outputDir + "/" + baseName + ".cpp";
  std::ofstream file(path);

  file << "// Path: " << path << std::endl;
  file << "// This file was automatically generated by generateAST.cpp"
       << std::endl;

  file << "#include <iostream>" << std::endl;
  file << "#include <vector>" << std::endl;
  file << "class " << baseName << " {"
       << std::endl; // This is the base class declaration
  for (std::string type : types) {
    std::string className = trim(type.substr(0, type.find(":")));
    std::string fields = trim(type.substr(type.find(":") + 1));
    defineType(file, baseName, className, fields);
  }

  file << "};" << std::endl;
  file.close();
}

void defineType(std::ofstream &file, const std::string baseName,
                const std::string className, const std::string fieldList) {
  file << "\tclass " << className << " {"
       << std::endl; // nested class declaration(is static because cpp has
                     // nested static classes by default)

  file << "\t\t" << className << "(" << fieldList << ") {"
       << std::endl; // constructor

  std::vector<std::string> fields = split(fieldList, ", ");

  for (std::string field : fields) {
    std::string name = field.substr(field.find(" "));
    file << "\t\t\tthis->" << name << " = " << name << ";"
         << std::endl; // this.field = field;
  }
  file << "\t\t}" << std::endl;
  for (std::string field : fields) {
    file << "\t\tconst " << field << ";" << std::endl; // field declaration
  }
  file << "\t};" << std::endl;
}

std::vector<std::string> split(const std::string &str,
                               const std::string delimiter) {
  std::vector<std::string> tokens;
  size_t prev = 0, pos = 0;
  do {
    pos = str.find(delimiter, prev);
    if (pos == std::string::npos)
      pos = str.length();
    std::string token = str.substr(prev, pos - prev);
    if (!token.empty())
      tokens.push_back(token);
    prev = pos + delimiter.length();
  } while (pos < str.length() && prev < str.length());
  return tokens;
}

std::string trim(const std::string &str) {
  size_t first = str.find_first_not_of(' ');
  size_t last = str.find_last_not_of(' ');

  if (first == std::string::npos || last == std::string::npos) {
    // The string is empty or contains only spaces
    return "";
  }

  return str.substr(first, last - first + 1);
}
