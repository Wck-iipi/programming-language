#include "generateAST.h"
#include <iostream>

void generateHeaders() {}

int main(int argc, char **argv) {
  if (argc != 2) {
    throw new std::runtime_error("Usage: generateAST <output directory>\n");
    exit(-1);
  }
  std::cout << "Generating AST in location:" << std::endl;
  std::string outputDir = argv[1];
  std::cout << outputDir << std::endl;
  defineAst(outputDir, "Expr",
            std::vector<std::string>{
                // add : instead of ->
                //     , instead of |
                "Assign : Token left, Expr right",
                "Logical: Expr left, Token op, Expr right",
                "Binary   : Expr left, Token op, Expr right",
                "Grouping : Expr expression",
                "Literal  : loxTypes value",
                "Unary    : Token op, Expr right",
                "Variable : Token name",
            });
  defineAst(outputDir, "Stmt",
            std::vector<std::string>{
                "If : Expr condition, Stmt thenBranch, std::optional<Stmt> elseBranch", // NOLINT
                "Block      : std::vector<Stmt> statements",
                "Expression : Expr expression", "Print      : Expr expression",
                "Var        : Token name, std::optional<Expr> initializer",
                "While : Expr condition, Stmt body"});
}

void defineAst(const std::string outputDir, const std::string baseName,
               const std::vector<std::string> types) {
  std::string path = outputDir + "/" + baseName + ".h";
  std::ofstream file(path);

  file << "// Path: " << path << std::endl;
  file << "// This file was automatically generated by generateAST.cpp"
       << std::endl;

  file << "#pragma once" << std::endl;
  file << "#include <any>" << std::endl;
  file << "#include <memory>" << std::endl;
  file << "#include <iostream>" << std::endl;
  file << "#include <optional>" << std::endl;
  file << "#include \"./token.h\"" << std::endl;
  if (baseName != "Expr")
    file << "#include \"./Expr.h\"" << std::endl;
  // Anything above is comments and headers

  // Forward declaration of classes
  for (std::string type : types) {
    std::string className = trim(type.substr(0, type.find(":")));
    file << "class " << className << ";" << std::endl;
  }

  file << "using " << baseName << " = std::variant<";
  for (std::string type : types) {
    file << "std::shared_ptr<";
    std::string className = trim(type.substr(0, type.find(":")));
    if (type != types.back())
      file << className << ">, ";
    else
      file << className << ">>;" << std::endl;
  }

  for (std::string type : types) {
    std::string className = trim(type.substr(0, type.find(":")));
    std::string fields = trim(type.substr(type.find(":") + 1));
    defineType(file, baseName, className, fields);
  }
  file << std::endl;
  file.close();
  path = outputDir + "/" + baseName + ".cpp";
  std::ofstream cppFile(path);
  cppFile << "#include \"./" << baseName << ".h\"" << std::endl;
}

void defineType(std::ofstream &file, const std::string baseName,
                const std::string className, const std::string fieldList) {
  file << "class " << className << " {"
       << std::endl; // nested class declaration(is static because cpp has
                     // nested static classes by default)

  std::vector<std::string> fields = split(fieldList, ", ");

  file << "\tpublic:" << std::endl;
  file << "\t" << className << "("; // constructor
  for (std::string field : fields) {
    std::string type = trim(field.substr(0, field.find(" ")));
    std::string name = trim(field.substr(field.find(" ")));
    if (field != fields.back())
      file << type << " " << name << ", ";
    else
      file << type << " " << name << ") : ";
  }

  for (std::string field : fields) {
    std::string name = trim(field.substr(field.find(" ")));
    if (field != fields.back())
      file << name << "(" << name << "), ";
    else
      file << name << "(" << name << ") {}" << std::endl;
  }

  for (std::string field : fields) {
    std::string type = trim(field.substr(0, field.find(" ")));
    std::string name = trim(field.substr(field.find(" ")));
    file << "\t\tconst " << type << " " << name << ";"
         << std::endl; // field declaration
  }
  file << "};" << std::endl;
}

std::vector<std::string> split(const std::string &str,
                               const std::string delimiter) {
  std::vector<std::string> tokens;
  size_t prev = 0, pos = 0;
  do {
    pos = str.find(delimiter, prev);
    if (pos == std::string::npos)
      pos = str.length();
    std::string token = trim(str.substr(prev, pos - prev));
    if (!token.empty())
      tokens.push_back(token);
    prev = pos + delimiter.length();
  } while (pos < str.length() && prev < str.length());
  return tokens;
}

std::string trim(const std::string &str) {
  size_t first = str.find_first_not_of(' ');
  size_t last = str.find_last_not_of(' ');

  if (first == std::string::npos || last == std::string::npos) {
    // The string is empty or contains only spaces
    return "";
  }

  return str.substr(first, last - first + 1);
}
